{"version":3,"file":"73.bootstrap.js","mappings":"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","sources":["webpack:///./style.css","webpack:///./style.css?f696","webpack:///./index.ts","webpack:///../pkg/sliding_blocks.js","webpack:///../pkg/sliding_blocks_bg.js"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* TODO: Minimize CSS: https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production */\r\n\r\n* {\r\n    font-family: sans-serif;\r\n}\r\n\r\n#svg-puzzle {\r\n    /* TODO: Make this responsive. */\r\n    max-width: 100vw;\r\n    max-height: 100vh;\r\n}\r\n\r\n#svg-puzzle>path {\r\n    /*transition: transform 0.125s linear, filter 0.125s;*/\r\n    stroke-width: 0.025;\r\n}\r\n\r\n#svg-puzzle>path.dragging {\r\n    filter: contrast(1.5);\r\n}\r\n\r\n#svg-puzzle>path.shadowGoal {\r\n    fill-opacity: 0.25;\r\n    stroke-opacity: 0.5;\r\n}\r\n\r\n.puzzle-string {\r\n    font-family: monospace;\r\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./style.css\"],\"names\":[],\"mappings\":\"AAAA,0GAA0G;;AAE1G;IACI,uBAAuB;AAC3B;;AAEA;IACI,gCAAgC;IAChC,gBAAgB;IAChB,iBAAiB;AACrB;;AAEA;IACI,sDAAsD;IACtD,mBAAmB;AACvB;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,kBAAkB;IAClB,mBAAmB;AACvB;;AAEA;IACI,sBAAsB;AAC1B\",\"sourcesContent\":[\"/* TODO: Minimize CSS: https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production */\\r\\n\\r\\n* {\\r\\n    font-family: sans-serif;\\r\\n}\\r\\n\\r\\n#svg-puzzle {\\r\\n    /* TODO: Make this responsive. */\\r\\n    max-width: 100vw;\\r\\n    max-height: 100vh;\\r\\n}\\r\\n\\r\\n#svg-puzzle>path {\\r\\n    /*transition: transform 0.125s linear, filter 0.125s;*/\\r\\n    stroke-width: 0.025;\\r\\n}\\r\\n\\r\\n#svg-puzzle>path.dragging {\\r\\n    filter: contrast(1.5);\\r\\n}\\r\\n\\r\\n#svg-puzzle>path.shadowGoal {\\r\\n    fill-opacity: 0.25;\\r\\n    stroke-opacity: 0.5;\\r\\n}\\r\\n\\r\\n.puzzle-string {\\r\\n    font-family: monospace;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","import './style.css';\nimport { get_all_js_examples } from \"sliding-blocks\";\nimport interact from 'interactjs'; // TODO: Only install the parts you need: https://interactjs.io/docs/installation#npm-streamlined\nimport JSConfetti from 'js-confetti';\nconst jsConfetti = new JSConfetti();\nconst COMPONENT_BITS = 16;\nconst COMPONENT_MASK = (1 << COMPONENT_BITS) - 1;\nconst COMPONENT_SIGN_BIT = 1 << (COMPONENT_BITS - 1);\nconst COMPONENT_PRECISION = 32;\nfunction p(x, y) {\n    // x,y âˆˆ â„¤ * 1/COMPONENT_PRECISION, please\n    const packedX = (Math.round(x * COMPONENT_PRECISION) & COMPONENT_MASK) >>> 0;\n    const packedY = (Math.round(y * COMPONENT_PRECISION) & COMPONENT_MASK) >>> 0;\n    return (packedX << COMPONENT_BITS) | packedY;\n}\nfunction x(v) {\n    const x = (v >>> COMPONENT_BITS) & COMPONENT_MASK;\n    return ((x & COMPONENT_SIGN_BIT) ? (x | ~COMPONENT_MASK) : x) / COMPONENT_PRECISION;\n}\nfunction y(v) {\n    const y = v & COMPONENT_MASK;\n    return ((y & COMPONENT_SIGN_BIT) ? (y | ~COMPONENT_MASK) : y) / COMPONENT_PRECISION;\n}\nconst shift_tuple = (v, a, b) => p(a + x(v), b + y(v));\nconst shift = (v, w) => p(x(v) + x(w), y(v) + y(w));\nconst unshift = (v, w) => shift(v, scale(w, -1));\nconst scale = (v, s) => p(x(v) * s, y(v) * s);\nconst shift_shape = (shape, v) => new Set([...shape].map(p => shift(p, v)));\nconst unshift_shape = (shape, v) => shift_shape(shape, scale(v, -1));\nconst dot = (v, w) => x(v) * x(w) + y(v) * y(w);\nconst square = (x) => x * x;\nconst dist2 = (v, w) => Math.sqrt(square(x(v) - x(w)) + square(y(v) - y(w)));\nconst dist1 = (v, w) => Math.abs(x(v) - x(w)) + Math.abs(y(v) - y(w));\nfunction is_subset(a, b) {\n    return [...a].every(x => b.has(x));\n}\nfunction is_disjoint(a, b) {\n    return [...a].every(x => !b.has(x));\n}\nfunction union(shapes) {\n    let union = new Set();\n    for (const shape of shapes) {\n        for (const point of shape) {\n            union.add(point);\n        }\n    }\n    return union;\n}\nfunction get_extremes(coordinates_set) {\n    // Extract min-x and min-y.\n    // Assumes that coordinatesSet is nonempty.\n    // TODO: Is that a misassumption?\n    let min_x = Number.MAX_SAFE_INTEGER;\n    let min_y = Number.MAX_SAFE_INTEGER;\n    let max_x = Number.MIN_SAFE_INTEGER;\n    let max_y = Number.MIN_SAFE_INTEGER;\n    for (const point of coordinates_set) {\n        max_x = Math.max(max_x, x(point));\n        max_y = Math.max(max_y, y(point));\n        min_x = Math.min(min_x, x(point));\n        min_y = Math.min(min_y, y(point));\n    }\n    return [p(min_x, min_y), p(max_x, max_y)];\n}\nfunction shape_to_path(shape, inset) {\n    var _a;\n    const DIRS = [p(1, 0), p(0, -1), p(-1, 0), p(0, 1)];\n    let edgepoint_to_dir = new Map();\n    shape.forEach(point => {\n        const left = shift_tuple(point, -1, 0);\n        const right = shift_tuple(point, 1, 0);\n        const up = shift_tuple(point, 0, -1);\n        const down = shift_tuple(point, 0, 1);\n        // We maintain the invariant that we touch the shape with\n        // our right hand. So if we're moving upwards, the shape\n        // is not on the left:\n        if (!shape.has(left)) {\n            edgepoint_to_dir.set(shift_tuple(point, -0.5, 0), 1);\n        }\n        if (!shape.has(right)) {\n            edgepoint_to_dir.set(shift_tuple(point, 0.5, 0), 3);\n        }\n        if (!shape.has(up)) {\n            edgepoint_to_dir.set(shift_tuple(point, 0, -0.5), 0);\n        }\n        if (!shape.has(down)) {\n            edgepoint_to_dir.set(shift_tuple(point, 0, 0.5), 2);\n        }\n    });\n    let path = \"\";\n    let failsafe_counter = 0;\n    let start_edgepoint;\n    while ((start_edgepoint = (_a = edgepoint_to_dir.keys().next()) === null || _a === void 0 ? void 0 : _a.value) && failsafe_counter++ < 10000) {\n        let edgepoint = start_edgepoint;\n        let dir = edgepoint_to_dir.get(edgepoint);\n        let drawpoint = shift(edgepoint, scale(DIRS[(dir + 3) % 4], inset));\n        path += `M${x(drawpoint)} ${y(drawpoint)}`;\n        do {\n            const dirvec = DIRS[dir];\n            const forward = scale(dirvec, 0.5);\n            const backward = scale(dirvec, -0.5);\n            const left = scale(DIRS[(dir + 1) % 4], 0.5);\n            const right = scale(DIRS[(dir + 3) % 4], 0.5);\n            const center = shift(edgepoint, forward);\n            const horizontal = DIRS[(dir + 1) % 4];\n            const vertical = dirvec;\n            if (shape.has(shift(center, shift(left, forward)))) {\n                edgepoint = shift(center, left);\n                dir = (dir + 1) % 4;\n            }\n            else if (shape.has(shift(center, shift(right, forward)))) {\n                edgepoint = shift(center, forward);\n            }\n            else {\n                edgepoint = shift(center, right);\n                dir = (dir + 3) % 4;\n            }\n            const old_drawpoint = drawpoint;\n            drawpoint = shift(edgepoint, scale(DIRS[(dir + 3) % 4], inset));\n            const center_drawpoint = shift(center, shift(scale(horizontal, dot(horizontal, unshift(old_drawpoint, center))), scale(vertical, dot(vertical, unshift(drawpoint, center)))));\n            path += `C${x(center_drawpoint)} ${y(center_drawpoint)} ${x(center_drawpoint)} ${y(center_drawpoint)} ${x(drawpoint)} ${y(drawpoint)}`;\n            edgepoint_to_dir.delete(edgepoint);\n        } while (edgepoint != start_edgepoint && failsafe_counter++ < 10000);\n        path += \"Z\";\n    }\n    return path;\n}\nconst BOUNDS_CHAR = '.';\nfunction char_to_color(char, lightness = 0.75, alpha = 1) {\n    // TODO: Dark mode stuff?\n    if (char == BOUNDS_CHAR) {\n        return `#BBB`;\n    }\n    const code = char.charCodeAt(0);\n    const chroma = 0.2;\n    const hue = (code * 65557) % 360;\n    return `oklch(${lightness} ${chroma} ${hue} / ${alpha})`;\n}\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nconst svg_puzzle_container = document.getElementById(\"svg-puzzle-container\");\nconst svg_puzzle = document.createElementNS(SVG_NAMESPACE, \"svg\");\nsvg_puzzle.id = \"svg-puzzle\";\nsvg_puzzle.setAttribute(\"xmlns\", SVG_NAMESPACE);\nsvg_puzzle_container.appendChild(svg_puzzle);\nclass Block {\n    constructor(coordinates, char) {\n        let [min, max] = get_extremes(coordinates);\n        this.shape = unshift_shape(coordinates, min);\n        this.offset = min;\n        this.char = char;\n    }\n    client_to_point(clientX, clientY) {\n        this.svg_point.x = clientX;\n        this.svg_point.y = clientY;\n        const point = this.svg_point.matrixTransform(this.svg_sctm_inverse);\n        return p(point.x, point.y);\n    }\n    update_walking_offsets(walk) {\n        this.walking_offsets_time += walk.length;\n        this.walking_offsets = walk.concat(this.walking_offsets);\n    }\n    update_translation(dt) {\n        const time_scale = 100;\n        const walking_offsets = this.walking_offsets;\n        const walking_offsets_time = this.walking_offsets_time;\n        if (walking_offsets && walking_offsets.length > 0) {\n            const new_offsets_time = Math.max(0, walking_offsets_time - dt * Math.pow(Math.ceil(walking_offsets_time), 0.75) / time_scale);\n            this.walking_offsets_time = new_offsets_time;\n            while (walking_offsets.length > new_offsets_time + 2) {\n                walking_offsets.pop();\n            }\n            if (walking_offsets.length === 1) {\n                const offy = this.walking_offsets[0];\n                this.path.style.transform = `translate(${x(offy)}px, ${y(offy)}px)`;\n            }\n            else {\n                const lambda = new_offsets_time % 1;\n                const from = this.walking_offsets[Math.ceil(new_offsets_time)];\n                const to = this.walking_offsets[Math.floor(new_offsets_time)];\n                console.log(from, to);\n                this.path.style.transform = `translate(${lambda * x(from) + (1 - lambda) * x(to)}px, ${lambda * y(from) + (1 - lambda) * y(to)}px)`;\n            }\n        }\n    }\n    get_coordinates() {\n        return shift_shape(this.shape, this.offset);\n    }\n    construct_elem_path(inset = 1 / 32) {\n        let path = document.createElementNS(SVG_NAMESPACE, \"path\");\n        path.setAttribute(\"d\", shape_to_path(this.shape, this.char === BOUNDS_CHAR ? -inset : inset));\n        path.setAttribute(\"fill-rule\", \"evenodd\");\n        path.setAttribute(\"stroke\", char_to_color(this.char, 0.25));\n        if (this.char !== BOUNDS_CHAR) {\n            const pattern_id = `block-pattern-${this.char}`;\n            path.setAttribute(\"fill\", `url(#${pattern_id})`);\n        }\n        else {\n            path.setAttribute(\"fill\", \"#CCC\");\n        }\n        return path;\n    }\n    create_elem_pattern(svg_elem) {\n        var _a;\n        if (this.char !== BOUNDS_CHAR) {\n            const defs = (_a = svg_elem.querySelector(\"defs\")) !== null && _a !== void 0 ? _a : svg_elem.appendChild(document.createElementNS(SVG_NAMESPACE, \"defs\"));\n            const pattern = document.createElementNS(SVG_NAMESPACE, \"pattern\");\n            const pattern_id = `block-pattern-${this.char}`;\n            const [_, max] = get_extremes(this.shape);\n            pattern.setAttribute(\"id\", pattern_id);\n            pattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n            pattern.setAttribute(\"x\", \"-0.5\");\n            pattern.setAttribute(\"y\", \"-0.5\");\n            pattern.setAttribute(\"width\", `${x(max) + 1}`);\n            pattern.setAttribute(\"height\", `${y(max) + 1}`);\n            const rect = document.createElementNS(SVG_NAMESPACE, \"rect\");\n            rect.setAttribute(\"width\", `${x(max) + 1}`);\n            rect.setAttribute(\"height\", `${y(max) + 1}`);\n            rect.setAttribute(\"fill\", char_to_color(this.char));\n            pattern.appendChild(rect);\n            const code = this.char.charCodeAt(0);\n            for (let p of this.shape) {\n                for (let i = 0; i < 10; i++) {\n                    const letter = document.createElementNS(SVG_NAMESPACE, \"text\");\n                    const X = (52.092819851131311425 * code + 13.087032255978894794 * i) % 1 + x(p);\n                    const Y = (28.640673508054986905 * code + 94.824207530838495049 * i) % 1 + y(p);\n                    const d = (14.336965871263130613 * code + 40.125163576904165817 * i) % 360;\n                    const a = (72.313644289540589845 * code + 61.413884855320691933 * i) % 0.25;\n                    const f = (75.427959404814958242 * code + 85.346753489292519779 * i) % 0.4 + 0.2;\n                    letter.setAttribute(\"x\", X.toString());\n                    letter.setAttribute(\"y\", Y.toString());\n                    letter.setAttribute(\"fill\", char_to_color(this.char, 0.5, a));\n                    letter.setAttribute(\"font-size\", f.toString());\n                    letter.setAttribute(\"transform\", `rotate(${d} ${X} ${Y})`);\n                    letter.textContent = this.char;\n                    pattern.appendChild(letter);\n                }\n            }\n            defs.appendChild(pattern);\n        }\n    }\n    initialise_elem(svg_elem) {\n        this.create_elem_pattern(svg_elem);\n        const path = this.construct_elem_path();\n        this.path = path;\n        this.svg_elem = svg_elem;\n        this.svg_sctm_inverse = svg_elem.getScreenCTM().inverse();\n        this.svg_point = svg_elem.createSVGPoint();\n        svg_elem.appendChild(this.path);\n        this.walking_offsets = [];\n        this.walking_offsets_time = 0;\n        this.update_walking_offsets([this.offset]);\n        this.update_translation(0);\n    }\n    make_interactive(puzzle, blockarr_ix) {\n        if (!this.path || !this.svg_elem) {\n            return;\n        }\n        const blockstate = puzzle.blockstate;\n        const bounds = blockstate.bounds.get_coordinates();\n        let start_cursor_position;\n        let start_offset = this.offset;\n        let valid_offsets;\n        const start = (event) => {\n            start_offset = this.offset;\n            start_cursor_position = unshift(this.client_to_point(event.client.x, event.client.y), start_offset);\n            this.path.classList.add(\"dragging\");\n            const other_blocks_union = union(blockstate.blocks.filter((b, i) => i != blockarr_ix).map(b => b.get_coordinates()));\n            const offset_is_valid = (offset) => {\n                const block = shift_shape(this.shape, offset);\n                if (!is_subset(block, bounds))\n                    return false;\n                if (!is_disjoint(block, other_blocks_union))\n                    return false;\n                return true;\n            };\n            let queue = [start_offset];\n            valid_offsets = new Set([start_offset]);\n            while (queue.length > 0) {\n                let point = queue.shift();\n                for (let neighbor of [shift(point, p(0, 1)), shift(point, p(0, -1)), shift(point, p(1, 0)), shift(point, p(-1, 0))]) {\n                    if (valid_offsets.has(neighbor) || !offset_is_valid(neighbor))\n                        continue;\n                    valid_offsets.add(neighbor);\n                    queue.push(neighbor);\n                }\n            }\n        };\n        const move = (event) => {\n            const old_offset = this.offset;\n            const new_offset_unrounded = unshift(this.client_to_point(event.client.x, event.client.y), start_cursor_position);\n            // find closest offset to current position:\n            let new_offset = start_offset;\n            let closest_distance = Infinity;\n            for (let offset of valid_offsets) {\n                const dist = dist2(new_offset_unrounded, offset);\n                if (dist < closest_distance) {\n                    closest_distance = dist;\n                    new_offset = offset;\n                }\n            }\n            if (old_offset != new_offset) {\n                // Do BFS with path reconstruction from old_offset to new_offset\n                let queue = [old_offset];\n                let parents = { old_offset: null };\n                while (queue.length > 0) {\n                    let point = queue.shift();\n                    if (point == new_offset)\n                        break;\n                    for (let neighbor of [shift(point, p(0, 1)), shift(point, p(0, -1)), shift(point, p(1, 0)), shift(point, p(-1, 0))]) {\n                        if (neighbor in parents || !valid_offsets.has(neighbor))\n                            continue;\n                        parents[neighbor] = point;\n                        queue.push(neighbor);\n                    }\n                }\n                let path = [new_offset];\n                let backtrack = parents[new_offset];\n                while (backtrack !== old_offset) {\n                    path.push(backtrack);\n                    backtrack = parents[backtrack];\n                }\n                this.offset = new_offset;\n                this.update_walking_offsets(path);\n            }\n        };\n        const end = (event) => {\n            // Is new blockstate different from before?\n            if (start_offset !== this.offset) {\n                puzzle.move_counter += 1;\n                move_counter_elem.textContent = puzzle.move_counter.toString();\n                if (puzzle.won()) {\n                    if (puzzle.min_moves !== null && puzzle.move_counter < puzzle.min_moves)\n                        jsConfetti.addConfetti({ emojis: [\"ðŸž\"] });\n                    else if (puzzle.min_moves !== null && puzzle.move_counter === puzzle.min_moves)\n                        jsConfetti.addConfetti({ emojis: [\"ðŸ†\"] });\n                    else\n                        jsConfetti.addConfetti();\n                }\n            }\n            this.path.classList.remove(\"dragging\");\n        };\n        interact(this.path).draggable({\n            listeners: {\n                start: start,\n                move: move,\n                end: end\n            }\n        });\n    }\n}\nclass Blockstate {\n    constructor(bounds, blocks) {\n        [this.min, this.max] = get_extremes(bounds.shape);\n        this.bounds = bounds;\n        this.blocks = blocks;\n    }\n    static blockstate_from_string(str) {\n        const lines = str.split(/\\r?\\n/g);\n        let global_min_x = Number.MAX_SAFE_INTEGER;\n        let global_min_y = Number.MAX_SAFE_INTEGER;\n        let char_to_blockcoordinates = {};\n        let bounds_coordinates = new Set();\n        let Y = 0;\n        for (let line of lines) {\n            let X = 0;\n            for (let c of [...line]) {\n                if (!(/\\s/.test(c))) { // isn't out-of-bounds\n                    global_min_x = Math.min(global_min_x, X);\n                    global_min_y = Math.min(global_min_y, Y);\n                    if (c != BOUNDS_CHAR) {\n                        char_to_blockcoordinates[c] = char_to_blockcoordinates[c] || new Set();\n                        char_to_blockcoordinates[c].add(p(X, Y));\n                    }\n                    bounds_coordinates.add(p(X, Y));\n                }\n                X++;\n            }\n            Y++;\n        }\n        const min = p(global_min_x, global_min_y);\n        let bounds = new Block(unshift_shape(bounds_coordinates, min), BOUNDS_CHAR);\n        let blocks = Object.entries(char_to_blockcoordinates).map(([c, coordinates]) => new Block(unshift_shape(coordinates, min), c));\n        return new Blockstate(bounds, blocks);\n    }\n    to_string() {\n        // TODO: How many of these methods should I import from Rust?\n        let str = \"\";\n        const block_coordinates = this.blocks.map(b => [b, b.get_coordinates()]);\n        const bounds = this.bounds.get_coordinates();\n        for (let Y = y(this.min); Y <= y(this.max); Y++) {\n            for (let X = x(this.min); X <= x(this.max); X++) {\n                let found = false;\n                for (let [b, coordinates] of block_coordinates) {\n                    if (coordinates.has(p(X, Y))) {\n                        str += b.char;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    if (bounds.has(p(X, Y)))\n                        str += BOUNDS_CHAR;\n                    else\n                        str += \" \";\n                }\n            }\n            str += \"\\n\";\n        }\n        return str;\n    }\n    initialise(svg_elem, goal_offsets) {\n        svg_elem.innerHTML = \"\";\n        const width = x(this.max) - x(this.min) + 1;\n        const height = y(this.max) - y(this.min) + 1;\n        svg_elem.setAttribute(\"viewBox\", `${x(this.min) - 1} ${y(this.min) - 1} ${width + 1} ${height + 1}`);\n        this.svg_elem = svg_elem;\n        this.bounds.initialise_elem(svg_elem);\n        for (let block_ix = 0; block_ix < this.blocks.length; block_ix++) {\n            if (goal_offsets[block_ix] !== null) {\n                const block = this.blocks[block_ix];\n                const shadow_elem = block.construct_elem_path(0);\n                const shadow_offset = goal_offsets[block_ix];\n                shadow_elem.classList.add(\"shadowGoal\");\n                shadow_elem.setAttribute(\"transform\", `translate(${x(shadow_offset)}, ${y(shadow_offset)})`);\n                svg_elem.appendChild(shadow_elem);\n            }\n        }\n        for (let block of this.blocks)\n            block.initialise_elem(svg_elem);\n    }\n    make_interactive(puzzle) {\n        for (let blockarr_ix = 0; blockarr_ix < this.blocks.length; blockarr_ix++) {\n            const block = this.blocks[blockarr_ix];\n            block.make_interactive(puzzle, blockarr_ix);\n        }\n    }\n}\nclass Puzzle {\n    constructor(start_string, goal_string, min_moves = null) {\n        this.min_moves = min_moves;\n        this.move_counter = 0;\n        // TODO: Lots of error-checking on shapes that's also done in Rust\n        const start_blockstate = Blockstate.blockstate_from_string(start_string);\n        this.blockstate = start_blockstate;\n        const goal_blockstate = Blockstate.blockstate_from_string(goal_string);\n        this.goal_offsets = this.blockstate.blocks.map(block => {\n            for (let goal_block of goal_blockstate.blocks) {\n                if (goal_block.char === block.char)\n                    return goal_block.offset;\n            }\n            return null;\n        });\n        this.start_string = start_blockstate.to_string();\n        this.goal_string = goal_blockstate.to_string();\n    }\n    won() {\n        const goal_offsets = this.goal_offsets;\n        return this.blockstate.blocks.every((b, ix) => goal_offsets[ix] === null || b.offset === goal_offsets[ix]);\n    }\n    initialise(svg_elem) {\n        this.blockstate = Blockstate.blockstate_from_string(this.start_string);\n        this.blockstate.initialise(svg_elem, this.goal_offsets);\n        this.blockstate.make_interactive(this);\n        this.move_counter = 0;\n        move_counter_elem.textContent = \"0\";\n    }\n}\nconst change_puzzle_dialog = document.getElementById(\"change-puzzle-dialog\");\nconst change_puzzle_btn = document.getElementById(\"change-puzzle-btn\");\nconst puzzle_textarea_start = document.getElementById(\"puzzle-textarea-start\");\nconst puzzle_textarea_goal = document.getElementById(\"puzzle-textarea-goal\");\nconst puzzle_submit_btn = document.getElementById(\"puzzle-submit-btn\");\nconst move_counter_elem = document.getElementById(\"move-counter\");\nchange_puzzle_btn.addEventListener(\"click\", () => {\n    puzzle_textarea_goal.value = current_puzzle.goal_string;\n    puzzle_textarea_start.value = current_puzzle.start_string;\n    change_puzzle_dialog.showModal();\n});\npuzzle_submit_btn.addEventListener(\"click\", e => {\n    e.preventDefault();\n    const start_string = puzzle_textarea_start.value;\n    const goal_string = puzzle_textarea_goal.value;\n    change_puzzle_dialog.close();\n    current_puzzle = new Puzzle(start_string, goal_string);\n    current_puzzle.initialise(svg_puzzle);\n});\nconst puzzle_selection = document.getElementById(\"puzzle-selection\");\nconst predefined_puzzles = get_all_js_examples();\nfor (let js_puzzle of predefined_puzzles) {\n    const option = document.createElement(\"option\");\n    option.textContent = js_puzzle.name;\n    option.value = js_puzzle.name;\n    puzzle_selection.appendChild(option);\n}\npuzzle_selection.addEventListener(\"change\", () => {\n    // TODO: Use indices as names instead\n    const name = puzzle_selection.value;\n    const js_puzzle = predefined_puzzles.find(js_puzzle => js_puzzle.name === name);\n    puzzle_textarea_start.value = js_puzzle.start;\n    puzzle_textarea_goal.value = js_puzzle.goal;\n});\nlet current_puzzle = new Puzzle(`\r\n      tt\r\n      tt\r\n    ......\r\n    .ppoo.\r\n     ypog\r\n     ....\r\n      ..\r\n      ..\r\n`, `\r\n      ..\r\n      ..\r\n    ......\r\n    ......\r\n     ....\r\n     ....\r\n      tt\r\n      tt\r\n`, 5);\ncurrent_puzzle.initialise(svg_puzzle);\nlet timestamp;\nfunction animate(t) {\n    const dt = timestamp ? t - timestamp : 0;\n    timestamp = t;\n    for (let block of current_puzzle.blockstate.blocks)\n        block.update_translation(dt);\n    requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n","import * as wasm from \"./sliding_blocks_bg.wasm\";\nimport { __wbg_set_wasm } from \"./sliding_blocks_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./sliding_blocks_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n/**\n* @param {string} start\n* @param {string} goal\n* @returns {(string)[]}\n*/\nexport function solve_puzzle(start, goal) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(start, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(goal, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.solve_puzzle(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v3 = getArrayJsValueFromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4, 4);\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @returns {(JsPuzzle)[]}\n*/\nexport function get_all_js_examples() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.get_all_js_examples(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4, 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nconst JsPuzzleFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jspuzzle_free(ptr >>> 0));\n/**\n*/\nexport class JsPuzzle {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsPuzzle.prototype);\n        obj.__wbg_ptr = ptr;\n        JsPuzzleFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsPuzzleFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jspuzzle_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jspuzzle_name(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} arg0\n    */\n    set name(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jspuzzle_name(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {string}\n    */\n    get start() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jspuzzle_start(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} arg0\n    */\n    set start(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jspuzzle_start(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {string}\n    */\n    get goal() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jspuzzle_goal(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} arg0\n    */\n    set goal(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jspuzzle_goal(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {number}\n    */\n    get min_moves() {\n        const ret = wasm.__wbg_get_jspuzzle_min_moves(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set min_moves(arg0) {\n        wasm.__wbg_set_jspuzzle_min_moves(this.__wbg_ptr, arg0);\n    }\n}\n\nexport function __wbg_jspuzzle_new(arg0) {\n    const ret = JsPuzzle.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"names":["___CSS_LOADER_EXPORT___","push","module","id","options","styleTagTransform","setAttributes","insert","domAPI","insertStyleElement","locals","jsConfetti","COMPONENT_BITS","COMPONENT_MASK","COMPONENT_SIGN_BIT","COMPONENT_PRECISION","p","x","y","packedX","Math","round","packedY","v","shift_tuple","a","b","shift","w","unshift","scale","s","shift_shape","shape","Set","map","unshift_shape","dot","square","dist2","sqrt","is_disjoint","every","has","union","shapes","point","add","get_extremes","coordinates_set","min_x","Number","MAX_SAFE_INTEGER","min_y","max_x","MIN_SAFE_INTEGER","max_y","max","min","shape_to_path","inset","_a","DIRS","edgepoint_to_dir","Map","forEach","left","right","up","down","set","start_edgepoint","path","failsafe_counter","keys","next","value","edgepoint","dir","get","drawpoint","dirvec","forward","center","horizontal","vertical","old_drawpoint","center_drawpoint","delete","BOUNDS_CHAR","char_to_color","char","lightness","alpha","charCodeAt","SVG_NAMESPACE","svg_puzzle_container","document","getElementById","svg_puzzle","createElementNS","setAttribute","appendChild","Block","constructor","coordinates","this","offset","client_to_point","clientX","clientY","svg_point","matrixTransform","svg_sctm_inverse","update_walking_offsets","walk","walking_offsets_time","length","walking_offsets","concat","update_translation","dt","new_offsets_time","pow","ceil","pop","offy","style","transform","lambda","from","to","floor","console","log","get_coordinates","construct_elem_path","pattern_id","create_elem_pattern","svg_elem","defs","querySelector","pattern","_","rect","code","i","letter","X","Y","d","f","toString","textContent","initialise_elem","getScreenCTM","inverse","createSVGPoint","make_interactive","puzzle","blockarr_ix","blockstate","bounds","start_cursor_position","valid_offsets","start_offset","draggable","listeners","start","event","client","classList","other_blocks_union","blocks","filter","offset_is_valid","block","queue","neighbor","move","old_offset","new_offset_unrounded","new_offset","closest_distance","Infinity","dist","parents","backtrack","end","move_counter","move_counter_elem","won","min_moves","addConfetti","emojis","remove","Blockstate","blockstate_from_string","str","lines","split","global_min_x","global_min_y","char_to_blockcoordinates","bounds_coordinates","line","c","test","Object","entries","to_string","block_coordinates","found","initialise","goal_offsets","innerHTML","width","height","block_ix","shadow_elem","shadow_offset","Puzzle","start_string","goal_string","start_blockstate","goal_blockstate","goal_block","ix","change_puzzle_dialog","change_puzzle_btn","puzzle_textarea_start","puzzle_textarea_goal","puzzle_submit_btn","addEventListener","current_puzzle","showModal","e","preventDefault","close","puzzle_selection","predefined_puzzles","js_puzzle","option","createElement","name","find","goal","timestamp","animate","t","requestAnimationFrame","wasm","__wbg_set_wasm","val","cachedTextDecoder","TextDecoder","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getUint8Memory0","byteLength","Uint8Array","memory","buffer","getStringFromWasm0","ptr","len","subarray","heap","Array","fill","undefined","heap_next","addHeapObject","obj","idx","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","read","written","passStringToWasm0","malloc","realloc","mem","slice","cachedInt32Memory0","getInt32Memory0","Int32Array","cachedUint32Memory0","takeObject","ret","getObject","dropObject","get_all_js_examples","retptr","__wbindgen_add_to_stack_pointer","r0","r1","v1","Uint32Array","result","getArrayJsValueFromWasm0","__wbindgen_free","JsPuzzleFinalization","FinalizationRegistry","register","unregister","__wbg_jspuzzle_free","JsPuzzle","__wrap","create","prototype","__wbg_ptr","__destroy_into_raw","free","deferred1_0","deferred1_1","__wbg_get_jspuzzle_name","arg0","ptr0","__wbindgen_malloc","__wbindgen_realloc","len0","__wbg_set_jspuzzle_name","__wbg_get_jspuzzle_start","__wbg_set_jspuzzle_start","__wbg_get_jspuzzle_goal","__wbg_set_jspuzzle_goal","__wbg_get_jspuzzle_min_moves","__wbg_set_jspuzzle_min_moves","__wbg_jspuzzle_new","__wbindgen_string_new","arg1","__wbindgen_throw","Error"],"sourceRoot":""}
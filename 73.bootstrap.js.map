{"version":3,"file":"73.bootstrap.js","mappings":"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","sources":["webpack:///./style.css","webpack:///./style.css?f696","webpack:///./index.ts","webpack:///../pkg/sliding_blocks.js","webpack:///../pkg/sliding_blocks_bg.js"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* TODO: Minimize CSS: https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production */\r\n\r\n* {\r\n    font-family: sans-serif;\r\n}\r\n\r\nheader *,\r\ndialog * {\r\n    font-size: min(3vw, 3vh, 20px);\r\n}\r\n\r\nhtml,\r\nbody {\r\n    margin: 0;\r\n    padding: 0;\r\n    overflow: hidden;\r\n    height: 100%;\r\n    width: 100%;\r\n}\r\n\r\nbody {\r\n    background: linear-gradient(0.25turn, #BBCCEE, #CCEEFF, #CCDDAA, #EEEEBB, #FFCCCC);\r\n}\r\n\r\nheader {\r\n    height: 2em;\r\n    width: 100%;\r\n    background: #FFF8;\r\n    display: flex;\r\n    gap: 1em;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n#svg-puzzle-container,\r\n#svg-puzzle {\r\n    height: 100%;\r\n    width: 100%;\r\n    max-width: 100vw;\r\n    max-height: calc(100vh - 2em);\r\n}\r\n\r\n#svg-puzzle>path {\r\n    stroke-width: 0.025;\r\n}\r\n\r\n#svg-puzzle>path.dragging {\r\n    filter: contrast(1.5);\r\n}\r\n\r\n#svg-puzzle>path.shadowGoal {\r\n    fill-opacity: 0.25;\r\n    stroke-opacity: 0.5;\r\n}\r\n\r\n#change-puzzle-dialog[open] {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1em;\r\n    width: 20em;\r\n    align-items: center;\r\n    border-radius: 0.5em;\r\n}\r\n\r\n#puzzle-dialog-buttons {\r\n    display: flex;\r\n    flex-direction: row;\r\n    gap: 1em;\r\n}\r\n\r\n#error-msg {\r\n    color: darkred;\r\n}\r\n\r\n.puzzle-string {\r\n    font-family: monospace;\r\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./style.css\"],\"names\":[],\"mappings\":\"AAAA,0GAA0G;;AAE1G;IACI,uBAAuB;AAC3B;;AAEA;;IAEI,8BAA8B;AAClC;;AAEA;;IAEI,SAAS;IACT,UAAU;IACV,gBAAgB;IAChB,YAAY;IACZ,WAAW;AACf;;AAEA;IACI,kFAAkF;AACtF;;AAEA;IACI,WAAW;IACX,WAAW;IACX,iBAAiB;IACjB,aAAa;IACb,QAAQ;IACR,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;;IAEI,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,6BAA6B;AACjC;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,kBAAkB;IAClB,mBAAmB;AACvB;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,QAAQ;IACR,WAAW;IACX,mBAAmB;IACnB,oBAAoB;AACxB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,QAAQ;AACZ;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,sBAAsB;AAC1B\",\"sourcesContent\":[\"/* TODO: Minimize CSS: https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production */\\r\\n\\r\\n* {\\r\\n    font-family: sans-serif;\\r\\n}\\r\\n\\r\\nheader *,\\r\\ndialog * {\\r\\n    font-size: min(3vw, 3vh, 20px);\\r\\n}\\r\\n\\r\\nhtml,\\r\\nbody {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n    overflow: hidden;\\r\\n    height: 100%;\\r\\n    width: 100%;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    background: linear-gradient(0.25turn, #BBCCEE, #CCEEFF, #CCDDAA, #EEEEBB, #FFCCCC);\\r\\n}\\r\\n\\r\\nheader {\\r\\n    height: 2em;\\r\\n    width: 100%;\\r\\n    background: #FFF8;\\r\\n    display: flex;\\r\\n    gap: 1em;\\r\\n    justify-content: center;\\r\\n    align-items: center;\\r\\n}\\r\\n\\r\\n#svg-puzzle-container,\\r\\n#svg-puzzle {\\r\\n    height: 100%;\\r\\n    width: 100%;\\r\\n    max-width: 100vw;\\r\\n    max-height: calc(100vh - 2em);\\r\\n}\\r\\n\\r\\n#svg-puzzle>path {\\r\\n    stroke-width: 0.025;\\r\\n}\\r\\n\\r\\n#svg-puzzle>path.dragging {\\r\\n    filter: contrast(1.5);\\r\\n}\\r\\n\\r\\n#svg-puzzle>path.shadowGoal {\\r\\n    fill-opacity: 0.25;\\r\\n    stroke-opacity: 0.5;\\r\\n}\\r\\n\\r\\n#change-puzzle-dialog[open] {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    gap: 1em;\\r\\n    width: 20em;\\r\\n    align-items: center;\\r\\n    border-radius: 0.5em;\\r\\n}\\r\\n\\r\\n#puzzle-dialog-buttons {\\r\\n    display: flex;\\r\\n    flex-direction: row;\\r\\n    gap: 1em;\\r\\n}\\r\\n\\r\\n#error-msg {\\r\\n    color: darkred;\\r\\n}\\r\\n\\r\\n.puzzle-string {\\r\\n    font-family: monospace;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","import './style.css';\nimport { solve_puzzle, get_all_js_examples } from \"sliding-blocks\";\nimport interact from 'interactjs'; // TODO: Only install the parts you need: https://interactjs.io/docs/installation#npm-streamlined\nimport JSConfetti from 'js-confetti';\nconst jsConfetti = new JSConfetti();\nconst COMPONENT_BITS = 16;\nconst COMPONENT_MASK = (1 << COMPONENT_BITS) - 1;\nconst COMPONENT_SIGN_BIT = 1 << (COMPONENT_BITS - 1);\nconst COMPONENT_PRECISION = 32;\nfunction p(x, y) {\n    // x,y ∈ ℤ * 1/COMPONENT_PRECISION, please\n    const packedX = (Math.round(x * COMPONENT_PRECISION) & COMPONENT_MASK) >>> 0;\n    const packedY = (Math.round(y * COMPONENT_PRECISION) & COMPONENT_MASK) >>> 0;\n    return (packedX << COMPONENT_BITS) | packedY;\n}\nfunction x(v) {\n    const x = (v >>> COMPONENT_BITS) & COMPONENT_MASK;\n    return ((x & COMPONENT_SIGN_BIT) ? (x | ~COMPONENT_MASK) : x) / COMPONENT_PRECISION;\n}\nfunction y(v) {\n    const y = v & COMPONENT_MASK;\n    return ((y & COMPONENT_SIGN_BIT) ? (y | ~COMPONENT_MASK) : y) / COMPONENT_PRECISION;\n}\nconst shift_tuple = (v, a, b) => p(a + x(v), b + y(v));\nconst shift = (v, w) => p(x(v) + x(w), y(v) + y(w));\nconst unshift = (v, w) => shift(v, scale(w, -1));\nconst scale = (v, s) => p(x(v) * s, y(v) * s);\nconst shift_shape = (shape, v) => new Set([...shape].map(p => shift(p, v)));\nconst unshift_shape = (shape, v) => shift_shape(shape, scale(v, -1));\nconst dot = (v, w) => x(v) * x(w) + y(v) * y(w);\nconst square = (x) => x * x;\nconst dist2 = (v, w) => Math.sqrt(square(x(v) - x(w)) + square(y(v) - y(w)));\nconst dist1 = (v, w) => Math.abs(x(v) - x(w)) + Math.abs(y(v) - y(w));\nfunction is_subset(a, b) {\n    return [...a].every(x => b.has(x));\n}\nfunction is_disjoint(a, b) {\n    return [...a].every(x => !b.has(x));\n}\nfunction union(shapes) {\n    let union = new Set();\n    for (const shape of shapes) {\n        for (const point of shape) {\n            union.add(point);\n        }\n    }\n    return union;\n}\nfunction get_extremes(coordinates_set) {\n    // Extract min-x and min-y.\n    // Assumes that coordinatesSet is nonempty.\n    let min_x = Number.MAX_SAFE_INTEGER;\n    let min_y = Number.MAX_SAFE_INTEGER;\n    let max_x = Number.MIN_SAFE_INTEGER;\n    let max_y = Number.MIN_SAFE_INTEGER;\n    for (const point of coordinates_set) {\n        max_x = Math.max(max_x, x(point));\n        max_y = Math.max(max_y, y(point));\n        min_x = Math.min(min_x, x(point));\n        min_y = Math.min(min_y, y(point));\n    }\n    return [p(min_x, min_y), p(max_x, max_y)];\n}\nfunction shape_to_path(shape, inset) {\n    var _a;\n    const DIRS = [p(1, 0), p(0, -1), p(-1, 0), p(0, 1)];\n    let edgepoint_to_dir = new Map();\n    shape.forEach(point => {\n        const left = shift_tuple(point, -1, 0);\n        const right = shift_tuple(point, 1, 0);\n        const up = shift_tuple(point, 0, -1);\n        const down = shift_tuple(point, 0, 1);\n        // We maintain the invariant that we touch the shape with\n        // our right hand. So if we're moving upwards, the shape\n        // is not on the left:\n        if (!shape.has(left)) {\n            edgepoint_to_dir.set(shift_tuple(point, -0.5, 0), 1);\n        }\n        if (!shape.has(right)) {\n            edgepoint_to_dir.set(shift_tuple(point, 0.5, 0), 3);\n        }\n        if (!shape.has(up)) {\n            edgepoint_to_dir.set(shift_tuple(point, 0, -0.5), 0);\n        }\n        if (!shape.has(down)) {\n            edgepoint_to_dir.set(shift_tuple(point, 0, 0.5), 2);\n        }\n    });\n    let path = \"\";\n    let failsafe_counter = 0;\n    let start_edgepoint;\n    while ((start_edgepoint = (_a = edgepoint_to_dir.keys().next()) === null || _a === void 0 ? void 0 : _a.value) && failsafe_counter++ < 10000) {\n        let edgepoint = start_edgepoint;\n        let dir = edgepoint_to_dir.get(edgepoint);\n        let drawpoint = shift(edgepoint, scale(DIRS[(dir + 3) % 4], inset));\n        path += `M${x(drawpoint)} ${y(drawpoint)}`;\n        do {\n            const dirvec = DIRS[dir];\n            const forward = scale(dirvec, 0.5);\n            const backward = scale(dirvec, -0.5);\n            const left = scale(DIRS[(dir + 1) % 4], 0.5);\n            const right = scale(DIRS[(dir + 3) % 4], 0.5);\n            const center = shift(edgepoint, forward);\n            const horizontal = DIRS[(dir + 1) % 4];\n            const vertical = dirvec;\n            if (shape.has(shift(center, shift(left, forward)))) {\n                edgepoint = shift(center, left);\n                dir = (dir + 1) % 4;\n            }\n            else if (shape.has(shift(center, shift(right, forward)))) {\n                edgepoint = shift(center, forward);\n            }\n            else {\n                edgepoint = shift(center, right);\n                dir = (dir + 3) % 4;\n            }\n            const old_drawpoint = drawpoint;\n            drawpoint = shift(edgepoint, scale(DIRS[(dir + 3) % 4], inset));\n            const center_drawpoint = shift(center, shift(scale(horizontal, dot(horizontal, unshift(old_drawpoint, center))), scale(vertical, dot(vertical, unshift(drawpoint, center)))));\n            path += `C${x(center_drawpoint)} ${y(center_drawpoint)} ${x(center_drawpoint)} ${y(center_drawpoint)} ${x(drawpoint)} ${y(drawpoint)}`;\n            edgepoint_to_dir.delete(edgepoint);\n        } while (edgepoint != start_edgepoint && failsafe_counter++ < 10000);\n        path += \"Z\";\n    }\n    return path;\n}\nconst BOUNDS_CHAR = '.';\nfunction char_to_color(char, lightness = 0.75, alpha = 1) {\n    // TODO: Dark mode stuff?\n    if (char == BOUNDS_CHAR) {\n        return `#BBB`;\n    }\n    const code = char.codePointAt(0);\n    const chroma = 0.2;\n    const hue = (code * 65557) % 360;\n    return `oklch(${lightness} ${chroma} ${hue} / ${alpha})`;\n}\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nconst svg_puzzle_container = document.getElementById(\"svg-puzzle-container\");\nconst svg_puzzle = document.createElementNS(SVG_NAMESPACE, \"svg\");\nsvg_puzzle.id = \"svg-puzzle\";\nsvg_puzzle.setAttribute(\"xmlns\", SVG_NAMESPACE);\nsvg_puzzle_container.appendChild(svg_puzzle);\nclass Block {\n    constructor(coordinates, char) {\n        let [min, max] = get_extremes(coordinates);\n        this.shape = unshift_shape(coordinates, min);\n        this.offset = min;\n        this.char = char;\n    }\n    client_to_point(clientX, clientY) {\n        this.svg_point.x = clientX;\n        this.svg_point.y = clientY;\n        const point = this.svg_point.matrixTransform(this.svg_sctm_inverse);\n        return p(point.x, point.y);\n    }\n    update_walking_offsets(walk) {\n        this.walking_offsets_time += walk.length;\n        this.walking_offsets = walk.concat(this.walking_offsets);\n    }\n    update_translation(dt) {\n        const time_scale = 100;\n        const walking_offsets = this.walking_offsets;\n        const walking_offsets_time = this.walking_offsets_time;\n        if (walking_offsets && walking_offsets.length > 0) {\n            const new_offsets_time = Math.max(0, walking_offsets_time - dt * Math.pow(Math.ceil(walking_offsets_time), 0.75) / time_scale);\n            this.walking_offsets_time = new_offsets_time;\n            while (walking_offsets.length > new_offsets_time + 2) {\n                walking_offsets.pop();\n            }\n            if (walking_offsets.length === 1) {\n                const offy = this.walking_offsets[0];\n                this.path.style.transform = `translate(${x(offy)}px, ${y(offy)}px)`;\n            }\n            else {\n                const lambda = new_offsets_time % 1;\n                const from = this.walking_offsets[Math.ceil(new_offsets_time)];\n                const to = this.walking_offsets[Math.floor(new_offsets_time)];\n                this.path.style.transform = `translate(${lambda * x(from) + (1 - lambda) * x(to)}px, ${lambda * y(from) + (1 - lambda) * y(to)}px)`;\n            }\n        }\n    }\n    get_coordinates() {\n        return shift_shape(this.shape, this.offset);\n    }\n    construct_elem_path(inset = 1 / 32) {\n        let path = document.createElementNS(SVG_NAMESPACE, \"path\");\n        path.setAttribute(\"d\", shape_to_path(this.shape, this.char === BOUNDS_CHAR ? -inset : inset));\n        path.setAttribute(\"fill-rule\", \"evenodd\");\n        path.setAttribute(\"stroke\", char_to_color(this.char, 0.25));\n        if (this.char !== BOUNDS_CHAR) {\n            const pattern_id = `block-pattern-${this.char}`;\n            path.setAttribute(\"fill\", `url(#${pattern_id})`);\n        }\n        else {\n            path.setAttribute(\"fill\", \"#CCC\");\n        }\n        return path;\n    }\n    create_elem_pattern(svg_elem) {\n        var _a;\n        if (this.char !== BOUNDS_CHAR) {\n            const defs = (_a = svg_elem.querySelector(\"defs\")) !== null && _a !== void 0 ? _a : svg_elem.appendChild(document.createElementNS(SVG_NAMESPACE, \"defs\"));\n            const pattern = document.createElementNS(SVG_NAMESPACE, \"pattern\");\n            const pattern_id = `block-pattern-${this.char}`;\n            const [_, max] = get_extremes(this.shape);\n            pattern.setAttribute(\"id\", pattern_id);\n            pattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n            pattern.setAttribute(\"x\", \"-0.5\");\n            pattern.setAttribute(\"y\", \"-0.5\");\n            pattern.setAttribute(\"width\", `${x(max) + 1}`);\n            pattern.setAttribute(\"height\", `${y(max) + 1}`);\n            const rect = document.createElementNS(SVG_NAMESPACE, \"rect\");\n            rect.setAttribute(\"width\", `${x(max) + 1}`);\n            rect.setAttribute(\"height\", `${y(max) + 1}`);\n            rect.setAttribute(\"fill\", char_to_color(this.char));\n            pattern.appendChild(rect);\n            const code = this.char.codePointAt(0);\n            for (let p of this.shape) {\n                for (let i = 0; i < 10; i++) {\n                    const letter = document.createElementNS(SVG_NAMESPACE, \"text\");\n                    const X = (52.092819851131311425 * code + 13.087032255978894794 * i) % 1 + x(p);\n                    const Y = (28.640673508054986905 * code + 94.824207530838495049 * i) % 1 + y(p);\n                    const d = (14.336965871263130613 * code + 40.125163576904165817 * i) % 360;\n                    const a = (72.313644289540589845 * code + 61.413884855320691933 * i) % 0.25;\n                    const f = (75.427959404814958242 * code + 85.346753489292519779 * i) % 0.4 + 0.2;\n                    letter.setAttribute(\"x\", X.toString());\n                    letter.setAttribute(\"y\", Y.toString());\n                    letter.setAttribute(\"fill\", char_to_color(this.char, 0.5, a));\n                    letter.setAttribute(\"font-size\", f.toString());\n                    letter.setAttribute(\"transform\", `rotate(${d} ${X} ${Y})`);\n                    letter.textContent = this.char;\n                    pattern.appendChild(letter);\n                }\n            }\n            defs.appendChild(pattern);\n        }\n    }\n    initialise_elem(svg_elem) {\n        this.create_elem_pattern(svg_elem);\n        const path = this.construct_elem_path();\n        this.path = path;\n        this.svg_elem = svg_elem;\n        this.svg_sctm_inverse = svg_elem.getScreenCTM().inverse();\n        this.svg_point = svg_elem.createSVGPoint();\n        svg_elem.appendChild(this.path);\n        this.walking_offsets = [];\n        this.walking_offsets_time = 0;\n        this.update_walking_offsets([this.offset]);\n        this.update_translation(0);\n    }\n    make_interactive(puzzle, blockarr_ix) {\n        if (!this.path || !this.svg_elem) {\n            return;\n        }\n        const blockstate = puzzle.blockstate;\n        const bounds = blockstate.bounds.get_coordinates();\n        let start_cursor_position;\n        let start_offset = this.offset;\n        let valid_offsets;\n        const start = (event) => {\n            start_offset = this.offset;\n            start_cursor_position = unshift(this.client_to_point(event.client.x, event.client.y), start_offset);\n            this.path.classList.add(\"dragging\");\n            const other_blocks_union = union(blockstate.blocks.filter((b, i) => i != blockarr_ix).map(b => b.get_coordinates()));\n            const offset_is_valid = (offset) => {\n                const block = shift_shape(this.shape, offset);\n                if (!is_subset(block, bounds))\n                    return false;\n                if (!is_disjoint(block, other_blocks_union))\n                    return false;\n                return true;\n            };\n            let queue = [start_offset];\n            valid_offsets = new Set([start_offset]);\n            while (queue.length > 0) {\n                let point = queue.shift();\n                for (let neighbor of [shift(point, p(0, 1)), shift(point, p(0, -1)), shift(point, p(1, 0)), shift(point, p(-1, 0))]) {\n                    if (valid_offsets.has(neighbor) || !offset_is_valid(neighbor))\n                        continue;\n                    valid_offsets.add(neighbor);\n                    queue.push(neighbor);\n                }\n            }\n        };\n        const move = (event) => {\n            const old_offset = this.offset;\n            const new_offset_unrounded = unshift(this.client_to_point(event.client.x, event.client.y), start_cursor_position);\n            // find closest offset to current position:\n            let new_offset = start_offset;\n            let closest_distance = Infinity;\n            for (let offset of valid_offsets) {\n                const dist = dist2(new_offset_unrounded, offset);\n                if (dist < closest_distance) {\n                    closest_distance = dist;\n                    new_offset = offset;\n                }\n            }\n            if (old_offset != new_offset) {\n                // Do BFS with path reconstruction from old_offset to new_offset\n                let queue = [old_offset];\n                let parents = { old_offset: null };\n                while (queue.length > 0) {\n                    let point = queue.shift();\n                    if (point == new_offset)\n                        break;\n                    for (let neighbor of [shift(point, p(0, 1)), shift(point, p(0, -1)), shift(point, p(1, 0)), shift(point, p(-1, 0))]) {\n                        if (neighbor in parents || !valid_offsets.has(neighbor))\n                            continue;\n                        parents[neighbor] = point;\n                        queue.push(neighbor);\n                    }\n                }\n                let path = [new_offset];\n                let backtrack = parents[new_offset];\n                while (backtrack !== old_offset) {\n                    path.push(backtrack);\n                    backtrack = parents[backtrack];\n                }\n                this.offset = new_offset;\n                this.update_walking_offsets(path);\n            }\n        };\n        const end = (event) => {\n            // Is new blockstate different from before?\n            if (start_offset !== this.offset) {\n                puzzle.add_to_history(blockstate);\n                if (puzzle.won()) {\n                    const confetti_number = 24;\n                    if (puzzle.min_moves !== null && puzzle.history_ix < puzzle.min_moves)\n                        jsConfetti.addConfetti({ emojis: [\"🐞\"], confettiNumber: confetti_number });\n                    else if (puzzle.min_moves !== null && puzzle.history_ix === puzzle.min_moves)\n                        jsConfetti.addConfetti({ emojis: [\"🏆\"], confettiNumber: confetti_number });\n                    else\n                        jsConfetti.addConfetti({ confettiNumber: confetti_number, confettiColors: puzzle.blockstate.blocks.map(b => char_to_color(b.char)) });\n                }\n            }\n            this.path.classList.remove(\"dragging\");\n        };\n        interact(this.path).draggable({\n            listeners: {\n                start: start,\n                move: move,\n                end: end\n            }\n        });\n    }\n}\nclass Blockstate {\n    constructor(bounds, blocks) {\n        [this.min, this.max] = get_extremes(bounds.shape);\n        this.bounds = bounds;\n        this.blocks = blocks;\n    }\n    static blockstate_from_string(str) {\n        const lines = str.split(/\\r?\\n/g);\n        let global_min_x = Number.MAX_SAFE_INTEGER;\n        let global_min_y = Number.MAX_SAFE_INTEGER;\n        let char_to_blockcoordinates = {};\n        let bounds_coordinates = new Set();\n        let Y = 0;\n        for (let line of lines) {\n            let X = 0;\n            for (let c of [...line]) {\n                if (!(/\\s/.test(c))) { // isn't out-of-bounds\n                    global_min_x = Math.min(global_min_x, X);\n                    global_min_y = Math.min(global_min_y, Y);\n                    if (c != BOUNDS_CHAR) {\n                        char_to_blockcoordinates[c] = char_to_blockcoordinates[c] || new Set();\n                        char_to_blockcoordinates[c].add(p(X, Y));\n                    }\n                    bounds_coordinates.add(p(X, Y));\n                }\n                X++;\n            }\n            Y++;\n        }\n        const min = p(global_min_x, global_min_y);\n        let bounds = new Block(unshift_shape(bounds_coordinates, min), BOUNDS_CHAR);\n        let blocks = Object.entries(char_to_blockcoordinates).map(([c, coordinates]) => new Block(unshift_shape(coordinates, min), c));\n        blocks.sort((a, b) => a.char.localeCompare(b.char)); // Any sort order suffices\n        return new Blockstate(bounds, blocks);\n    }\n    to_string() {\n        // TODO: How many of these methods should I import from Rust?\n        let str = \"\";\n        const block_coordinates = this.blocks.map(b => [b, b.get_coordinates()]);\n        const bounds = this.bounds.get_coordinates();\n        for (let Y = y(this.min); Y <= y(this.max); Y++) {\n            for (let X = x(this.min); X <= x(this.max); X++) {\n                let found = false;\n                for (let [b, coordinates] of block_coordinates) {\n                    if (coordinates.has(p(X, Y))) {\n                        str += b.char;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    if (bounds.has(p(X, Y)))\n                        str += BOUNDS_CHAR;\n                    else\n                        str += \" \";\n                }\n            }\n            str += \"\\n\";\n        }\n        return str;\n    }\n    initialise(svg_elem, goal_offsets) {\n        svg_elem.innerHTML = \"\";\n        const width = x(this.max) - x(this.min) + 1;\n        const height = y(this.max) - y(this.min) + 1;\n        svg_elem.setAttribute(\"viewBox\", `${x(this.min) - 1} ${y(this.min) - 1} ${width + 1} ${height + 1}`);\n        this.svg_elem = svg_elem;\n        this.bounds.initialise_elem(svg_elem);\n        for (let block_ix = 0; block_ix < this.blocks.length; block_ix++) {\n            if (goal_offsets[block_ix] !== null) {\n                const block = this.blocks[block_ix];\n                const shadow_elem = block.construct_elem_path(0);\n                const shadow_offset = goal_offsets[block_ix];\n                shadow_elem.classList.add(\"shadowGoal\");\n                shadow_elem.setAttribute(\"transform\", `translate(${x(shadow_offset)}, ${y(shadow_offset)})`);\n                svg_elem.appendChild(shadow_elem);\n            }\n        }\n        for (let block of this.blocks)\n            block.initialise_elem(svg_elem);\n    }\n    make_interactive(puzzle) {\n        for (let blockarr_ix = 0; blockarr_ix < this.blocks.length; blockarr_ix++) {\n            const block = this.blocks[blockarr_ix];\n            block.make_interactive(puzzle, blockarr_ix);\n        }\n    }\n}\nclass Puzzle {\n    constructor(start_string, goal_string, min_moves = null) {\n        this.min_moves = min_moves;\n        // TODO: Lots of error-checking on shapes that's also done in Rust\n        const start_blockstate = Blockstate.blockstate_from_string(start_string);\n        this.blockstate = start_blockstate;\n        const goal_blockstate = Blockstate.blockstate_from_string(goal_string);\n        this.goal_offsets = this.blockstate.blocks.map(block => {\n            for (let goal_block of goal_blockstate.blocks) {\n                if (goal_block.char === block.char)\n                    return goal_block.offset;\n            }\n            return null;\n        });\n        this.start_string = start_blockstate.to_string();\n        this.goal_string = goal_blockstate.to_string();\n    }\n    won() {\n        const goal_offsets = this.goal_offsets;\n        return this.blockstate.blocks.every((b, ix) => goal_offsets[ix] === null || b.offset === goal_offsets[ix]);\n    }\n    add_to_history(blockstate) {\n        while (this.history.length > this.history_ix + 1)\n            this.history.pop();\n        this.history.push(blockstate.blocks.map(x => x.offset));\n        this.history_ix++;\n        move_counter_elem.textContent = this.history_ix.toString();\n    }\n    // TODO: Disable buttons when history at limit\n    history_forward() {\n        if (this.history_ix < this.history.length - 1) {\n            this.history_ix++;\n            this.update_blockstate_from_history();\n        }\n    }\n    history_backward() {\n        if (this.history_ix > 0) {\n            this.history_ix--;\n            this.update_blockstate_from_history();\n        }\n    }\n    update_blockstate_from_history() {\n        const blockstate = this.blockstate;\n        const blocks = blockstate.blocks;\n        const bounds = blockstate.bounds.get_coordinates();\n        for (let blockarr_ix = 0; blockarr_ix < blocks.length; blockarr_ix++) {\n            const block = blocks[blockarr_ix];\n            const old_offset = block.offset;\n            const new_offset = this.history[this.history_ix][blockarr_ix];\n            if (old_offset !== new_offset) {\n                const other_blocks_union = union(blocks.filter((b, i) => i != blockarr_ix).map(b => b.get_coordinates()));\n                const offset_is_valid = (offset) => {\n                    const offset_block = shift_shape(block.shape, offset);\n                    if (!is_subset(offset_block, bounds))\n                        return false;\n                    if (!is_disjoint(offset_block, other_blocks_union))\n                        return false;\n                    return true;\n                };\n                // Do BFS with path reconstruction from old_offset to new_offset\n                let queue = [old_offset];\n                let parents = {};\n                parents[old_offset] = null;\n                let success = false;\n                while (queue.length > 0) {\n                    let point = queue.shift();\n                    if (point == new_offset) {\n                        success = true;\n                        break;\n                    }\n                    for (let neighbor of [shift(point, p(0, 1)), shift(point, p(0, -1)), shift(point, p(1, 0)), shift(point, p(-1, 0))]) {\n                        if (neighbor in parents || !offset_is_valid(neighbor))\n                            continue;\n                        parents[neighbor] = point;\n                        queue.push(neighbor);\n                    }\n                }\n                if (success) {\n                    let path = [];\n                    let backtrack = new_offset;\n                    while (backtrack !== old_offset) {\n                        path.push(backtrack);\n                        backtrack = parents[backtrack];\n                    }\n                    block.update_walking_offsets(path);\n                }\n                else {\n                    // This should never happen.\n                    block.update_walking_offsets([new_offset]);\n                }\n            }\n        }\n        // Finally, update all the offsets for real\n        // (We should only ever one offset in the first place, so we could\n        //  get away with doing this in the previous loop already, but if\n        //  anything ever breaks, this makes it easier to hunt down)\n        for (let blockarr_ix = 0; blockarr_ix < blocks.length; blockarr_ix++) {\n            const block = blocks[blockarr_ix];\n            block.offset = this.history[this.history_ix][blockarr_ix];\n        }\n        move_counter_elem.textContent = (this.history_ix === this.history.length - 1) ? this.history_ix.toString() : `${this.history_ix}/${this.history.length - 1}`;\n    }\n    initialise(svg_elem) {\n        this.blockstate = Blockstate.blockstate_from_string(this.start_string);\n        this.blockstate.initialise(svg_elem, this.goal_offsets);\n        this.blockstate.make_interactive(this);\n        this.history_ix = -1;\n        this.history = [];\n        this.add_to_history(this.blockstate);\n    }\n}\nconst change_puzzle_dialog = document.getElementById(\"change-puzzle-dialog\");\nconst change_puzzle_btn = document.getElementById(\"change-puzzle-btn\");\nconst reset_puzzle_btn = document.getElementById(\"reset-puzzle-btn\");\nconst puzzle_textarea_start = document.getElementById(\"puzzle-textarea-start\");\nconst puzzle_textarea_goal = document.getElementById(\"puzzle-textarea-goal\");\nconst puzzle_submit_btn = document.getElementById(\"puzzle-submit-btn\");\nconst puzzle_solve_btn = document.getElementById(\"puzzle-solve-btn\");\nconst move_counter_elem = document.getElementById(\"move-counter\");\nconst history_forward_btn = document.getElementById(\"history-forward\");\nconst history_backward_btn = document.getElementById(\"history-backward\");\nconst error_msg_span = document.getElementById(\"error-msg\");\nchange_puzzle_btn.addEventListener(\"click\", () => {\n    puzzle_textarea_goal.value = current_puzzle.goal_string;\n    puzzle_textarea_start.value = current_puzzle.start_string;\n    error_msg_span.textContent = \"\";\n    change_puzzle_dialog.showModal();\n});\nreset_puzzle_btn.addEventListener(\"click\", () => {\n    current_puzzle.initialise(svg_puzzle);\n});\nhistory_backward_btn.addEventListener(\"click\", () => {\n    current_puzzle.history_backward();\n});\nhistory_forward_btn.addEventListener(\"click\", () => {\n    current_puzzle.history_forward();\n});\npuzzle_submit_btn.addEventListener(\"click\", e => {\n    e.preventDefault();\n    const start_string = puzzle_textarea_start.value;\n    const goal_string = puzzle_textarea_goal.value;\n    change_puzzle_dialog.close();\n    error_msg_span.textContent = \"\";\n    current_puzzle = new Puzzle(start_string, goal_string);\n    current_puzzle.initialise(svg_puzzle);\n});\npuzzle_solve_btn.addEventListener(\"click\", e => {\n    e.preventDefault();\n    const start_string = puzzle_textarea_start.value;\n    const goal_string = puzzle_textarea_goal.value;\n    let solution;\n    try {\n        solution = solve_puzzle(start_string, goal_string);\n        if (solution === undefined) {\n            error_msg_span.textContent = \"No solution exists.\";\n        }\n        else {\n            const solution_blockstates = solution.map(s => Blockstate.blockstate_from_string(s));\n            change_puzzle_dialog.close();\n            current_puzzle = new Puzzle(start_string, goal_string);\n            current_puzzle.initialise(svg_puzzle);\n            for (let blockstate of solution_blockstates.slice(1)) {\n                current_puzzle.add_to_history(blockstate);\n            }\n            current_puzzle.history_ix = 0;\n            current_puzzle.update_blockstate_from_history();\n        }\n    }\n    catch (e) {\n        error_msg_span.textContent = e.toString();\n    }\n});\nconst puzzle_selection = document.getElementById(\"puzzle-selection\");\nconst predefined_puzzles = get_all_js_examples().sort((a, b) => a.min_moves - b.min_moves);\nfor (let js_puzzle of predefined_puzzles) {\n    const option = document.createElement(\"option\");\n    option.textContent = `[${js_puzzle.min_moves}] ${js_puzzle.name}`;\n    option.value = js_puzzle.name;\n    puzzle_selection.appendChild(option);\n}\npuzzle_selection.addEventListener(\"change\", () => {\n    // TODO: Use indices as names instead\n    const name = puzzle_selection.value;\n    const js_puzzle = predefined_puzzles.find(js_puzzle => js_puzzle.name === name);\n    error_msg_span.textContent = \"\";\n    puzzle_textarea_start.value = Blockstate.blockstate_from_string(js_puzzle.start).to_string();\n    puzzle_textarea_goal.value = Blockstate.blockstate_from_string(js_puzzle.goal).to_string();\n});\nlet current_puzzle = new Puzzle(predefined_puzzles[0].start, predefined_puzzles[0].goal);\ncurrent_puzzle.initialise(svg_puzzle);\nlet timestamp;\nfunction animate(t) {\n    const dt = timestamp ? t - timestamp : 0;\n    timestamp = t;\n    for (let block of current_puzzle.blockstate.blocks)\n        block.update_translation(dt);\n    requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n","import * as wasm from \"./sliding_blocks_bg.wasm\";\nimport { __wbg_set_wasm } from \"./sliding_blocks_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./sliding_blocks_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n/**\n* @param {string} start\n* @param {string} goal\n* @returns {(string)[] | undefined}\n*/\nexport function solve_puzzle(start, goal) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(start, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(goal, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.solve_puzzle(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v3;\n        if (r0 !== 0) {\n            v3 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4, 4);\n        }\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @returns {(JsPuzzle)[]}\n*/\nexport function get_all_js_examples() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.get_all_js_examples(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4, 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nconst JsPuzzleFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jspuzzle_free(ptr >>> 0));\n/**\n*/\nexport class JsPuzzle {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsPuzzle.prototype);\n        obj.__wbg_ptr = ptr;\n        JsPuzzleFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsPuzzleFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jspuzzle_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jspuzzle_name(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} arg0\n    */\n    set name(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jspuzzle_name(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {string}\n    */\n    get start() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jspuzzle_start(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} arg0\n    */\n    set start(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jspuzzle_start(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {string}\n    */\n    get goal() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jspuzzle_goal(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} arg0\n    */\n    set goal(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jspuzzle_goal(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {number}\n    */\n    get min_moves() {\n        const ret = wasm.__wbg_get_jspuzzle_min_moves(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set min_moves(arg0) {\n        wasm.__wbg_set_jspuzzle_min_moves(this.__wbg_ptr, arg0);\n    }\n}\n\nexport function __wbg_jspuzzle_new(arg0) {\n    const ret = JsPuzzle.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"names":["___CSS_LOADER_EXPORT___","push","module","id","options","styleTagTransform","setAttributes","insert","domAPI","insertStyleElement","locals","jsConfetti","COMPONENT_BITS","COMPONENT_MASK","COMPONENT_SIGN_BIT","COMPONENT_PRECISION","p","x","y","packedX","Math","round","packedY","v","shift_tuple","a","b","shift","w","unshift","scale","s","shift_shape","shape","Set","map","unshift_shape","dot","square","dist2","sqrt","is_subset","every","has","is_disjoint","union","shapes","point","add","get_extremes","coordinates_set","min_x","Number","MAX_SAFE_INTEGER","min_y","max_x","MIN_SAFE_INTEGER","max_y","max","min","shape_to_path","inset","_a","DIRS","edgepoint_to_dir","Map","forEach","left","right","up","down","set","start_edgepoint","path","failsafe_counter","keys","next","value","edgepoint","dir","get","drawpoint","dirvec","forward","center","horizontal","vertical","old_drawpoint","center_drawpoint","delete","BOUNDS_CHAR","char_to_color","char","lightness","alpha","codePointAt","SVG_NAMESPACE","svg_puzzle_container","document","getElementById","svg_puzzle","createElementNS","setAttribute","appendChild","Block","constructor","coordinates","this","offset","client_to_point","clientX","clientY","svg_point","matrixTransform","svg_sctm_inverse","update_walking_offsets","walk","walking_offsets_time","length","walking_offsets","concat","update_translation","dt","new_offsets_time","pow","ceil","pop","offy","style","transform","lambda","from","to","floor","get_coordinates","construct_elem_path","pattern_id","create_elem_pattern","svg_elem","defs","querySelector","pattern","_","rect","code","i","letter","X","Y","d","f","toString","textContent","initialise_elem","getScreenCTM","inverse","createSVGPoint","make_interactive","puzzle","blockarr_ix","blockstate","bounds","start_cursor_position","valid_offsets","start_offset","draggable","listeners","start","event","client","classList","other_blocks_union","blocks","filter","offset_is_valid","block","queue","neighbor","move","old_offset","new_offset_unrounded","new_offset","closest_distance","Infinity","dist","parents","backtrack","end","add_to_history","won","confetti_number","min_moves","history_ix","addConfetti","emojis","confettiNumber","confettiColors","remove","Blockstate","blockstate_from_string","str","lines","split","global_min_x","global_min_y","char_to_blockcoordinates","bounds_coordinates","line","c","test","Object","entries","sort","localeCompare","to_string","block_coordinates","found","initialise","goal_offsets","innerHTML","width","height","block_ix","shadow_elem","shadow_offset","Puzzle","start_string","goal_string","start_blockstate","goal_blockstate","goal_block","ix","history","move_counter_elem","history_forward","update_blockstate_from_history","history_backward","offset_block","success","change_puzzle_dialog","change_puzzle_btn","reset_puzzle_btn","puzzle_textarea_start","puzzle_textarea_goal","puzzle_submit_btn","puzzle_solve_btn","history_forward_btn","history_backward_btn","error_msg_span","addEventListener","current_puzzle","showModal","e","preventDefault","close","solution","undefined","solution_blockstates","slice","puzzle_selection","predefined_puzzles","js_puzzle","option","createElement","name","find","goal","timestamp","animate","t","requestAnimationFrame","wasm","__wbg_set_wasm","val","cachedTextDecoder","TextDecoder","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getUint8Memory0","byteLength","Uint8Array","memory","buffer","getStringFromWasm0","ptr","len","subarray","heap","Array","fill","heap_next","addHeapObject","obj","idx","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","read","written","passStringToWasm0","malloc","realloc","mem","charCodeAt","cachedInt32Memory0","getInt32Memory0","Int32Array","takeObject","ret","getObject","dropObject","cachedUint32Memory0","getArrayJsValueFromWasm0","Uint32Array","result","solve_puzzle","retptr","__wbindgen_add_to_stack_pointer","ptr0","__wbindgen_malloc","__wbindgen_realloc","len0","ptr1","len1","r0","r1","r2","v3","__wbindgen_free","get_all_js_examples","v1","JsPuzzleFinalization","FinalizationRegistry","register","unregister","__wbg_jspuzzle_free","JsPuzzle","__wrap","create","prototype","__wbg_ptr","__destroy_into_raw","free","deferred1_0","deferred1_1","__wbg_get_jspuzzle_name","arg0","__wbg_set_jspuzzle_name","__wbg_get_jspuzzle_start","__wbg_set_jspuzzle_start","__wbg_get_jspuzzle_goal","__wbg_set_jspuzzle_goal","__wbg_get_jspuzzle_min_moves","__wbg_set_jspuzzle_min_moves","__wbg_jspuzzle_new","__wbindgen_string_new","arg1","__wbindgen_throw","Error"],"sourceRoot":""}